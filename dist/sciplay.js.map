{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b838630f5f332a69b55b","webpack:///./src/extras/polyfills.js","webpack:///./src/sciplay.js","webpack:///./src/math/Vector.js","webpack:///./src/math/math.js","webpack:///./src/geometries/Ray.js","webpack:///./src/system/System.js","webpack:///./src/geometries/SpatialHash.js","webpack:///./src/renderer/Renderer.js","webpack:///./src/bodies/Rect.js","webpack:///./src/bodies/Body.js","webpack:///./src/extras/materials.json","webpack:///./src/geometries/AABB.js","webpack:///./src/bodies/Wave.js","webpack:///./src/bodies/Circle.js","webpack:///./src/bodies/Polygon.js"],"names":["lastTime","vendors","x","length","window","requestAnimationFrame","cancelAnimationFrame","callback","element","currTime","Date","getTime","timeToCall","Math","max","id","setTimeout","clearTimeout","sciplay","Vector","vector","renderer","ray","system","wave","rect","polygon","circle","y","prototype","clone","set","prop","val","add","vec","subtract","multiply","getX","getY","magnitude","sqrt","magnitudeSq","negate","dot","cross","angleTo","a","b","d","theta","acos","getAngle","mode","atan","atan2","PI","normalize","mag","v1","v2","angleBetween","degToRad","angle","radToDeg","distance","x1","y1","x2","y2","map","value","low1","high1","low2","high2","Ray","init","dir","degrees","origin","direction","cos","sin","invDirection","outerBodies","t","innerWidth","innerHeight","x0","y0","slope","numTests","trace","intersectionPoint","intersectingBody","intersectingSegment","rayID","currentRayId","intersectHash","hash","intersectCircle","radius","f","position","c","desc","t1","t2","ix","iy","updateIntersectionPoint","intersectPolygon","poly","isPointInterior","push","vertices","vertLength","intersection","forEach","vert","index","verts","seg2","intersectSegment","intPoint","segVec","seg","r","p","q","s","rxs","tmp","tNum","uNum","u","px","py","rx","ry","bucket","row","col","X","Y","tMaxX","tMaxY","tDeltaX","tDeltaY","stepX","stepY","cellSize","rowOffset","colOffset","backDir","backSegH","backSegV","height","width","backVInt","backHInt","tMaxOrigin","undefined","vDist","hDist","verticalSeg","horizontalSeg","vInt","hInt","sciDebug","ctx","beginPath","strokeStyle","ellipse","stroke","tx","ty","numRows","numCols","lineWidth","strokeRect","contents","body","intersectionPoints","status","hitsAABB","intersectAABB","aabb","type","segVeg","hashCoordinates","tx1","min","tx2","tmin","tmax","ty1","ty2","hit","R","Object","create","System","params","frames","objects","waves","childWaves","rays","divisor","floor","addFrame","frame","addRay","addWave","addChildWave","addObject","update","clear","insertBody","traverseWaves","children","child","SpatialHash","ceil","point","removeBody","idx","indexOf","splice","queryBody","nearby","queryPoint","h","math","Renderer","clearBackground","debug","background","canvas","document","createElement","appendChild","getElementById","getContext","drawBody","w","fillStyle","style","_mode","lineJoin","moveTo","lineTo","closePath","fill","i","v","drawWave","globalAlpha","intensity","render","self","_requestID","clearRect","fillRect","obj","j","keys","setSize","stop","requestID","start","options","B","defineProperty","get","m","updateVertices","console","warn","updateSegments","segments","bx","by","Body","constructor","mass","velocity","refractiveIndex","material","materialColor","mirror","error","freeze","_cachedVelocity","unfreeze","AABB","bounds","findMinMax","minx","miny","maxx","maxy","cx","cy","contains","ab","Wave","speedOfLight","waveSpeed","frequency","wavelength","parent","n1","n2","lastIntersection","createChildren","normal","bType","intSeg","normals","that","n","tmpTerm","tmpVec","rVec","theta1","theta2","asin","sin2theta2","tVec","normCopy","_r0","R0","_r0tmp","pow","T","RI","TI","rVecAngle","tVecAngle","reflectedWave","refractedWave","W","Error","_relativeVertices","relVert","inside","vi","vj","xi","yi","xj","yj","intersect"],"mappings":"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","file":"sciplay.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"sciplay\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sciplay\"] = factory();\n\telse\n\t\troot[\"sciplay\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b838630f5f332a69b55b\n **/","/* eslint \"max-len\": \"off\" */\n// Request animation frame shim\n(function() {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n\n    if (!window.cancelAnimationFrame) {\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n    }\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/polyfills.js\n **/","/* MATH OBJECTS */\nimport vector, {Vector} from './math/Vector';\nimport ray from './geometries/Ray';\n\n/* CORE OBJECTS */\nimport system from './system/System';\nimport renderer from './renderer/Renderer';\n\n/* BODIES */\nimport rect from './bodies/Rect';\nimport wave from './bodies/Wave';\nimport circle from './bodies/Circle';\nimport polygon from './bodies/Polygon';\n\nlet sciplay = function() {\n    return {\n        Vector, // for operations that return a new vector\n        vector, // actual vector constructor\n        renderer,\n        ray,\n        system,\n        wave,\n        rect,\n        polygon,\n        circle\n    };\n};\n\nexport default sciplay;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/sciplay.js\n **/","import {radToDeg} from './math';\n\nexport const Vector = function(x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n};\n\nVector.prototype = {\n    clone: function() {\n        return new Vector(this.x, this.y);\n    },\n    /**\n     * Generic Setter\n     * @param {string} prop - property to set\n     * @param {*} val - value to set\n     */\n    set: function(prop, val) {\n        if (prop === 'x') {\n            this.x = val;\n        } else if (prop === 'y') {\n            this.y = val;\n        }\n    },\n    add: function(vec) {\n        this.x += vec.x;\n        this.y += vec.y;\n    },\n    subtract: function(vec) {\n        this.x -= vec.x;\n        this.y -= vec.y;\n    },\n    multiply: function(vec) {\n        if (typeof vec === 'object') {\n            this.x *= vec.getX();\n            this.y *= vec.getY();\n        } else if (typeof vec === 'number') {\n            this.x *= vec;\n            this.y *= vec;\n        }\n    },\n    magnitude: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n    magnitudeSq: function() {\n        return this.x * this.x + this.y * this.y;\n    },\n    negate: function() {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    },\n    dot: function(vec) {\n        return this.x * vec.x + this.y * vec.y;\n    },\n    cross: function(vec) {\n        return this.x * vec.y - this.y * vec.x;\n    },\n    angleTo: function(vec) {\n        let a = this.magnitude();\n        let b = vec.magnitude();\n        let d = this.dot(vec);\n\n        let theta = Math.acos(d / (a * b));\n        return theta;\n    },\n    getAngle: function(mode) {\n        if (mode === 'DEGREES') {\n            return radToDeg(Math.atan(this.y / this.x));\n        }\n        let a = Math.atan2(this.y, this.x);\n        //return a;\n        return a < 0 ? Math.PI * 2 + a : a;\n    },\n    normalize: function(vec) {\n        let mag = this.magnitude();\n        this.x /= mag;\n        this.y /= mag;\n    }\n};\n\n// ---------- Static Methods -----------//\n/**\n * @static\n * @param {Vector} v1 - first Vector obj\n * @param {Vector} v2 - second Vector obj\n * @return {Vector}\n *\n * Adds two vectors, and returns a new one\n */\nVector.add = function(v1, v2) {\n    return new Vector(v1.x + v2.x, v1.y + v2.y);\n};\nVector.subtract = function(v1, v2) {\n    return new Vector(v1.x - v2.x, v1.y - v2.y);\n};\nVector.multiply = function(v1, v2) {\n    if (typeof v1 === 'number' && typeof v2 === 'number') {\n        return v1 * v2;\n    }\n\n    if (typeof v1 === 'object' && typeof v2 === 'number') {\n        return new Vector(v1.x * v2, v1.y * v2);\n    }\n\n    if (typeof v2 === 'object' && typeof v1 === 'number') {\n        return new Vector(v1 * v2.x, v1 * v2.y);\n    }\n};\nVector.dot = function(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n};\nVector.angleBetween = function(v1, v2) {\n    let a = v1.magnitude();\n    let b = v2.magnitude();\n    let d = v1.dot(v2);\n\n    let theta = Math.acos(d / (a * b));\n    return theta;\n};\n\nvar vector = function(x, y) {\n    return new Vector(x, y);\n};\n\nexport default vector;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/math/Vector.js\n **/","export const degToRad = function(angle) {\n    return angle * Math.PI / 180;\n};\n\nexport const radToDeg = function(angle) {\n    return angle * 180 / Math.PI;\n};\n\nexport const distance = function(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n};\n\nexport const map = function(value, low1, high1, low2, high2) {\n    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/math/math.js\n **/","/* eslint\n    \"no-unused-vars\": \"off\",\n */\nimport {distance, degToRad} from '../math/math';\nimport vector, {Vector} from '../math/Vector.js';\n\nlet Ray = {\n    /**\n     * Initialization\n     * @param {number} x - origin x\n     * @param {number} y - origin y\n     * @param {number} dir - direction in radians (or degrees if 'degrees' param\n     * = true)\n     * @param {bool} degrees - optional flag, if true, then read direction as\n     * degrees\n     */\n    init: function(x, y, dir, degrees) {\n        if (degrees) {\n            dir = degToRad(dir);\n        }\n\n        this.origin = vector(x, y);\n        this.direction = vector(Math.cos(dir), Math.sin(dir));\n        this.invDirection = vector(1 / this.direction.x, 1 / this.direction.y);\n        this.outerBodies = [];\n        this.t = window.innerWidth > window.innerHeight ? window.innerWidth : window.innerHeight;\n        let x0 = this.origin.x,\n            y0 = this.origin.y,\n            x1 = this.origin.x + this.direction.x * this.t,\n            y1 = this.origin.y + this.direction.y * this.t;\n        this.slope = (y1 - y0) / (x1 - x0);\n        // TODO: Figure out a way to give each ray a unique ID\n        this.numTests = 0;\n    },\n\n    /**\n     * Return the objects from spatial hash to perform collision detection on\n     * @param {SpatialHash} hash - hash from the System\n     */\n\n    trace: function(system) {\n        // Always use radians, regardless of mode\n        // Also angle should be in range 0 <= angle <= 2PI\n        //let angle = this.direction.getAngle();\n        this.intersectionPoint = null;\n        this.intersectingBody = null;\n        this.intersectingSegment = null;\n\n        // Iterate the rayID to ensure no duplicates\n        this.rayID = system.currentRayId++;\n        this.numTests = 0;      // debugging param - how many tests are run\n        this.intersectHash(system.hash);\n\n        // After going through all bodies and segments,\n        // if an intersection point was found...\n        if (this.intersectionPoint) {\n            return true;\n        }\n    },\n\n    /**\n     * Detect if ray intersects circle\n     * http://stackoverflow.com/questions/1073336/circle-line-segment-collision-detection-algorithm\n     *\n     * Using the following formula\n     * t^2 * (r DOT r) + 2t*( f DOT r ) + ( f DOT f - radius^2 ) = 0\n     * at^2 + bt + c where a = d.dot(d), b = 2*f.dot(d), c = f.dot(f)\n     * - radius^2\n     *      where:\n     *          d = end point of ray - start point of ray\n     *          t = scalar value - what we're solving for\n     *          r = ray vector\n     *          f = vector from center of sphere to origin of ray\n     *          radius = radius of circle\n     *\n     * 3x HIT cases:\n     *  -o->                    --|-->  |            |  --|->\n     * Impale(t1 hit,t2 hit), Poke(t1 hit,t2>1), ExitWound(t1<0, t2 hit),\n     *\n     * 3x MISS cases:\n     *     ->  o                     o ->              | -> |\n     * FallShort (t1>1,t2>1), Past (t1<0,t2<0), CompletelyInside(t1<0, t2>1)\n     *\n     * @param {Body} circle - circle body object\n     * @param {Vector} p - point of origin\n     * @param {Vector} r - ray vector\n     * @return {boolean} true if intersection was found, false otherwise\n     */\n    intersectCircle: function(circle) {\n        this.numTests += 1;\n        let radius = circle.radius;\n\n        let d = vector(this.direction.x * this.t, this.direction.y * this.t);\n        let f = Vector.subtract(this.origin, circle.position);//this.origin.clone();\n\n        // Solve the quadratic equation\n        let a = d.dot(d);\n        let b = 2 * f.dot(d);\n        let c = f.dot(f) - radius * radius;\n\n        // Descriminant b^2 - 4ac\n        let desc = (b * b) - (4 * a * c);\n\n        if (desc < 0) {\n            // No intersection\n        } else {\n            // Ray hit circle\n            // Two possible solutions\n            desc = Math.sqrt(desc);\n            let t1 = (-b - desc) / (2 * a);\n            let t2 = (-b + desc) / (2 * a);\n            let ix, iy;\n\n            // If t1 intersected the circle...\n            // Note: t1 is always closer than t2\n            if (t1 >= 0 && t1 <= 1) {\n                ix = this.origin.x + d.x * t1;\n                iy = this.origin.y + d.y * t1;\n                this.updateIntersectionPoint({x: ix, y: iy}, null, circle);\n                return true;\n            }\n\n            // If t1 doesn't intersect, check t2\n            if (t2 >= 0 && t2 <= 1) {\n                ix = this.origin.x + d.x * t2;\n                iy = this.origin.y + d.y * t2;\n                this.updateIntersectionPoint({x: ix, y: iy}, null, circle);\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    /**\n     * Handles case of ray-polygon intersection\n     * If an intersecting segment is found,\n     * set the props accordingly\n     * @private\n     * @param {Polygon} poly - rect body object\n     * @return {bool} true if intersected, otherwise false\n     */\n    intersectPolygon: function(poly) {\n        this.numTests += 1;\n        if (poly.isPointInterior(this.origin)) {\n            this.outerBodies.push(poly);\n        }\n        //let segs = poly.segments;\n        let vertices = poly.vertices;\n        let vertLength = vertices.length;\n        let intersection;\n        vertices.forEach((vert, index, verts) => {\n            let seg2;\n            if (index === vertLength - 1) {\n                seg2 = verts[0];\n            } else {\n                seg2 = verts[index + 1];\n            }\n\n            intersection = this.intersectSegment([vert, seg2]);\n            if (intersection) {\n                this.updateIntersectionPoint(intersection.intPoint, intersection.segVec, poly);\n            }\n        });\n\n        return typeof intersection !== 'undefined';\n    },\n    /**\n     * Detects Ray-Segment intersection - Returns intersection coords\n     * @param {Array} seg - segment vertices\n     * @param {Vector} dir - optional direction to use, otherwise use\n     * this.direction\n     * @return {Object} returns intersection point with body, or false\n     */\n    intersectSegment: function(seg, dir) {\n        let r = dir ?\n            vector(dir.x * this.t, dir.y * this.t) :  // Dir passed to fn\n            vector(this.t * this.direction.x, this.t * this.direction.y);   // Use ray dir\n        let p = vector(this.origin.x, this.origin.y);                           // Ray origin\n        let q = vector(seg[0].x, seg[0].y);                                     // Segment start point\n        let s = vector(seg[1].x - seg[0].x, seg[1].y - seg[0].y);               // Segment vector\n\n        // check for intersection\n        // t = (q  p) x s / (r x s)\n        // u = (q  p) x r / (r x s)\n        let rxs = r.cross(s);\n        let tmp = Vector.subtract(q, p);\n        let tNum = tmp.cross(s),\n            uNum = tmp.cross(r);\n\n        // t, u are distances traveled along vector\n        let t, u;\n        if (rxs !== 0) {\n            t = tNum / rxs;\n            u = uNum / rxs;\n        }\n\n        // TODO: handle collinear case\n        if (rxs === 0 && uNum === 0) {\n            // lines are collinear\n            return;\n        } else if (rxs === 0 && uNum !== 0) {\n            // lines are parallel and non-intersecting\n            return false;\n        } else if (rxs !== 0 && t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n            // Two lines intersect,\n            // and meet at the point\n            // p + tr = q + us\n            let px = p.x,\n                py = p.y,\n                rx = r.x,\n                ry = r.y,\n                ix = px + t * rx,\n                iy = py + t * ry;\n\n            return {\n                intPoint: vector(ix, iy),\n                segVec: s,\n                t\n            };\n        }\n\n        // Line segments do not intersect\n        // if we've gone through all the segments of the body,\n        //intersectionPoint = null;\n        return false;\n    },\n\n    /**\n     * Test for Ray-Hash bucket intersections\n     * @param {SpatialHash} hash - system.hash object\n     * @return {array} list of intersected buckets\n     *\n     * See here: http://www.cse.chalmers.se/edu/year/2011/course/TDA361_Computer_Graphics/grid.pdf\n         * The traversal algorithm consists of two phases: initialization and incremental traversal. The initialization\n            phase begins by identifying the voxel in which the ray origin, \n            u, is found. If the ray origin is outside\n            the grid, we find the point in which the ray enters the grid and take the adjacent voxel. The integer\n            variables X and Y are initialized to the starting voxel coordinates. In addition, the variables stepX and\n            stepY are initialized to either 1 or -1 indicating whether X and Y are incremented or decremented as the\n            ray crosses voxel boundaries (this is determined by the sign of the x and y components of \n            v).\n            Next, we determine the value of t at which the ray crosses the first vertical voxel boundary and\n            store it in variable tMaxX. We perform a similar computation in y and store the result in tMaxY. The\n            minimum of these two values will indicate how much we can travel along the ray and still remain in the\n            current voxel.\n            Finally, we compute tDeltaX and tDeltaY. TDeltaX indicates how far along the ray we must move\n            (in units of t) for the horizontal component of such a movement to equal the width of a voxel. Similarly,\n            we store in tDeltaY the amount of movement along the ray which has a vertical component equal to the\n            height of a voxel\n        *\n     */\n    intersectHash: function(hash) {\n        // TODO: Handle case where ray starts outside bounds\n\n        // Initialize variables\n        // Step 1. Initialization - determine starting voxel\n        let bucket = hash.hash(this.origin);\n        let {row, col} = bucket;\n        let X = col,\n            Y = row;\n        let tMaxX, tMaxY, tDeltaX, tDeltaY;\n        let stepX = this.direction.x < 0 ? -1 : 1,\n            stepY = this.direction.y < 0 ? -1 : 1;\n        let cellSize = hash.cellSize;\n\n        // Row and Col offset for picking which horizontal or veritcal segments\n        // to use for intersection tests\n        let rowOffset = stepY < 1 ? 0 : 1,\n            colOffset = stepX < 1 ? 0 : 1;\n\n        // FIXME: There's an issue when the ray starts inside a voxel -> it's\n        // tMaxX and tMaxY values should represent the distance to cross an\n        // entire voxel, not the distance from the origin to the nearest edge.\n        // To solve this, we could project backwards until we hit the opposite\n        // edges of the voxel, get the starting coordinates, then go from there\n\n        // Project Backwards\n        let backDir = this.direction.clone().negate();\n        let backSegH, backSegV;\n        if (stepX === 1 && stepY === 1) {\n            // Right and Down\n            // Intersect backDir with col and row, as is\n            backSegV = [vector(col * cellSize, 0), vector(col * cellSize, hash.height)];\n            backSegH = [vector(0, row * cellSize), vector(hash.width, row * cellSize)];\n        } else if (stepX === 1 && stepY === -1) {\n            // Right and Up\n            // Intersect backDir with col and row + 1\n            backSegV = [vector(col * cellSize, 0), vector(col * cellSize, hash.height)];\n            backSegH = [vector(0, (row + 1) * cellSize), vector(hash.width, (row + 1) * cellSize)];\n        } else if (stepX === -1 && stepY === 1) {\n            // Left and Down\n            // Intersect with col and row\n            backSegV = [vector((col + 1) * cellSize, 0), vector((col + 1) * cellSize, hash.height)];\n            backSegH = [vector(0, row * cellSize), vector(hash.width, row * cellSize)];\n        } else if (stepX === -1 && stepY === -1) {\n            // Left and Up\n            // intersect with col + 1 and row + 1\n            backSegV = [vector((col + 1) * cellSize, 0), vector((col + 1) * cellSize, hash.height)];\n            backSegH = [vector(0, (row + 1) * cellSize), vector(hash.width, (row + 1) * cellSize)];\n        }\n\n        // Trace backwards\n        let backVInt = this.intersectSegment(backSegV, backDir);\n        let backHInt = this.intersectSegment(backSegH, backDir);\n        let tMaxOrigin;\n\n        // Which is closer - backH or backV segment?\n        if (backVInt.intPoint === undefined && backHInt.intPoint === undefined) {\n            return;\n            // FIXME: Handle the case where ray is outside and pointing at the\n            // grid\n        } else if (backVInt.intPoint === undefined && backHInt.intPoint) {\n            tMaxOrigin = backHInt.intPoint;\n        } else if (backHInt.intPoint === undefined && backVInt.intPoint) {\n            tMaxOrigin = backVInt.intPoint;\n        } else if (backHInt.intPoint && backVInt.intPoint) {\n            let vDist = distance(this.origin.x, this.origin.y, backVInt.intPoint.x, backVInt.intPoint.y);\n            let hDist = distance(this.origin.x, this.origin.y, backHInt.intPoint.x, backHInt.intPoint.y);\n            if (vDist >= hDist) {\n                tMaxOrigin = backHInt.intPoint;\n            } else {\n                tMaxOrigin = backVInt.intPoint;\n            }\n        }\n\n        // Hash segments to test for distance to intersection\n        let verticalSeg = [\n                vector((col + colOffset) * cellSize, 0),\n                vector((col + colOffset) * cellSize, hash.height)\n            ],\n            horizontalSeg = [\n                vector(0, (row + rowOffset) * cellSize),\n                vector(hash.width, (row + rowOffset) * cellSize)\n            ];\n\n        // Step 2. Get distance to both vertical and horizontal hash segments\n        // Run hash intersection tests\n        let vInt = this.intersectSegment(verticalSeg),\n            hInt = this.intersectSegment(horizontalSeg);\n\n        if (window.sciDebug) {\n            if (vInt.intPoint && hInt.intPoint) {\n                window.ctx.beginPath();\n                window.ctx.strokeStyle = 'yellow';\n                window.ctx.ellipse(vInt.intPoint.x, vInt.intPoint.y, 8, 8, 0, 0, Math.PI * 2);\n                window.ctx.stroke();\n                window.ctx.beginPath();\n                window.ctx.strokeStyle = 'red';\n                window.ctx.ellipse(hInt.intPoint.x, hInt.intPoint.y, 8, 8, 0, 0, Math.PI * 2);\n                window.ctx.stroke();\n            }\n\n            if (backVInt.intPoint && backHInt.intPoint) {\n                window.ctx.beginPath();\n                window.ctx.strokeStyle = 'yellow';\n                window.ctx.ellipse(backVInt.intPoint.x, backVInt.intPoint.y, 8, 8, 0, 0, Math.PI * 2);\n                window.ctx.stroke();\n                window.ctx.beginPath();\n                window.ctx.strokeStyle = 'red';\n                window.ctx.ellipse(backHInt.intPoint.x, backHInt.intPoint.y, 8, 8, 0, 0, Math.PI * 2);\n                window.ctx.stroke();\n                window.ctx.beginPath();\n                window.ctx.ellipse(tMaxOrigin.x, tMaxOrigin.y, 8, 8, 0, 0, Math.PI * 2);\n                window.ctx.stroke();\n            }\n        }\n\n        // It's possible that ray doesn't intersect a segment, so doublecheck\n        // Then get distance to intersection point\n        let tx, ty;\n        if (vInt) {\n            tMaxX = distance(tMaxOrigin.x, tMaxOrigin.y, vInt.intPoint.x, vInt.intPoint.y);\n            // tx = distance(tMaxOrigin.x, tMaxOrigin.y, vInt.intPoint.x, vInt.intPoint.y);\n            // tMaxX = distance(this.origin.x, this.origin.y, vInt.intPoint.x, vInt.intPoint.y);\n        }\n        if (hInt) {\n            tMaxY = distance(tMaxOrigin.x, tMaxOrigin.y, hInt.intPoint.x, hInt.intPoint.y);\n            // ty = distance(tMaxOrigin.x, tMaxOrigin.y, hInt.intPoint.x, hInt.intPoint.y);\n            // tMaxY = distance(this.origin.x, this.origin.y, hInt.intPoint.x, hInt.intPoint.y);\n        }\n\n        // FIXME: Left here on 11/21 - Somethings' not working and I'm not sure\n        // what.......\n        // Store distances on separate var to hold onto values\n        tDeltaX = tMaxX;\n        tDeltaY = tMaxY;\n\n        // Step 3. Loop - step through hash, only if X and Y are within the right range\n        // TODO: Fix this - negative rays are not tracing\n        // FIXME: see todo\n        // through hash properly....not sure why\n        while (Y < hash.numRows &&\n                Y > -1 &&\n                X < hash.numCols &&\n                X > -1) {\n            // Draw buckets that ray overlaps\n            if (window.sciDebug) {\n                window.ctx.beginPath();\n                window.ctx.strokeStyle = 'orange';\n                window.ctx.lineWidth = 3;\n                window.ctx.strokeRect(X * cellSize, Y * cellSize, cellSize, cellSize);\n            }\n\n            // If we've found some contents in that hash bucket...\n            if (hash.contents[Y] && hash.contents[Y][X] && hash.contents[Y][X].length !== 0) {\n                // TODO: Here's where we need to check if the object is\n                // actually intersecting the ray\n                // Intersect all objects in this voxel only\n                let contents = hash.contents[Y][X];\n                contents.forEach(body => {\n                    if (body.intersectionPoints[this.rayID]) {\n                        // Already tested this body\n                        // It either hit or missed, if it hit, grab the point\n                        if (body.intersectionPoints[this.rayID].status === 'hit') {\n                            this.updateIntersectionPoint(\n                                body.intersectionPoints[this.rayID].intPoint,\n                                body.intersectionPoints[this.rayID].segVec,\n                                body\n                            );\n                            return;\n                        }\n\n                        // It missed, so do nothing;\n                        return;\n                    }\n\n                    // If ray and body haven't been tested, then test\n                    // If it hits the AABB, then perform\n                    // actual intersection tests\n                    let hitsAABB = this.intersectAABB(body.aabb);\n                    if (hitsAABB) {\n                        switch (body.type) {\n                            case 'polygon':\n                            case 'rectangle':\n                                this.intersectPolygon(body);\n                                break;\n                            case 'circle':\n                                this.intersectCircle(body);\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n\n                    // Flag body to know we've already tested this ray-body\n                    // combo\n                    if (this.intersectionPoint) {\n                        body.intersectionPoints[this.rayID] = {\n                            status: 'hit',\n                            intPoint: this.intersectionPoint,\n                            segVeg: this.intersectingSegment\n                        };\n                    } else {\n                        // If we missed, flag the body without\n                        // intersectionPoint\n                        body.intersectionPoints[this.rayID] = {status: 'miss'};\n                    }\n                });\n            }\n\n            // Increment X or Y step\n            if (tMaxX === undefined && tMaxY === undefined) {\n                break;\n            } else if (tMaxX === undefined) {\n                tMaxY += tDeltaY;\n                Y += stepY;\n            } else if (tMaxY === undefined) {\n                tMaxX += tDeltaX;\n                X += stepX;\n            } else if (tMaxX < tMaxY) {\n                // tMaxY += tDeltaY;\n                // Y += stepY;\n                tMaxX += tDeltaX;\n                X += stepX;\n            } else if (tMaxX >= tMaxY) {\n                // tMaxX += tDeltaX;\n                // X += stepX;\n                tMaxY += tDeltaY;\n                Y += stepY;\n            }\n        }\n\n        return {\n            hashCoordinates: {\n                x: X,\n                y: Y\n            },\n            intPoint: this.intersectionPoint\n        };\n    },\n\n    intersectAABB: function(aabb) {\n        //let tmin, tmax, tymin, tymax;\n\n        //let divx = this.invDirection.x;\n        //let divy = this.invDirection.y;\n        //if (divx >= 0) {\n            //tmin = (aabb.min.x - this.origin.x) * divx;\n            //tmax = (aabb.max.x - this.origin.x) * divx;\n        //} else {\n            //tmin = (aabb.max.x - this.origin.x) * divx;\n            //tmax = (aabb.min.x - this.origin.x) * divx;\n        //}\n        //if (divy >= 0) {\n            //tymin = (aabb.min.y - this.origin.y) * divy;\n            //tymax = (aabb.max.y - this.origin.y) * divy;\n        //} else {\n            //tymin = (aabb.max.y - this.origin.y) * divy;\n            //tymax = (aabb.min.y - this.origin.y) * divy;\n        //}\n        let tx1 = (aabb.min.x - this.origin.x) * this.invDirection.x;\n        let tx2 = (aabb.max.x - this.origin.x) * this.invDirection.x;\n\n        let tmin = Math.min(tx1, tx2);\n        let tmax = Math.max(tx1, tx2);\n\n        let ty1 = (aabb.min.y - this.origin.y) * this.invDirection.y;\n        let ty2 = (aabb.max.y - this.origin.y) * this.invDirection.y;\n\n        tmin = Math.max(tmin, Math.min(ty1, ty2));\n        tmax = Math.min(tmax, Math.max(ty1, ty2));\n        let hit = tmax >= tmin && tmax >= 0;\n        return hit;\n    },\n/*AABB.prototype.intersectSegment = function(pos, delta) {\n      var farTime, farTimeX, farTimeY, hit, nearTime, nearTimeX, nearTimeY, scaleX, scaleY, signX, signY;\n\n      scaleX = 1.0 / delta.x;\n      scaleY = 1.0 / delta.y;\n      signX = sign(scaleX);\n      signY = sign(scaleY);\n      nearTimeX = (this.pos.x - signX * (this.half.x + paddingX) - pos.x) * scaleX;\n      nearTimeY = (this.pos.y - signY * (this.half.y + paddingY) - pos.y) * scaleY;\n      farTimeX = (this.pos.x + signX * (this.half.x + paddingX) - pos.x) * scaleX;\n      farTimeY = (this.pos.y + signY * (this.half.y + paddingY) - pos.y) * scaleY;\n      if (nearTimeX > farTimeY || nearTimeY > farTimeX) {\n        return null;\n      }\n      nearTime = nearTimeX > nearTimeY ? nearTimeX : nearTimeY;\n      farTime = farTimeX < farTimeY ? farTimeX : farTimeY;\n      if (nearTime >= 1 || farTime <= 0) {\n        return null;\n      }\n      hit = new Hit(this);\n      hit.time = clamp(nearTime, 0, 1);\n      if (nearTimeX > nearTimeY) {\n        hit.normal.x = -signX;\n        hit.normal.y = 0;\n      } else {\n        hit.normal.x = 0;\n        hit.normal.y = -signY;\n      }\n      hit.delta.x = hit.time * delta.x;\n      hit.delta.y = hit.time * delta.y;\n      hit.pos.x = pos.x + hit.delta.x;\n      hit.pos.y = pos.y + hit.delta.y;\n      return hit;\n    };*/\n    /**\n     * Simple Ray-AABB Test\n     * Only returns if intersection exists, DOES NOT give distance to\n     * intersection\n     * 2D version of this: http://www.cg.cs.tu-bs.de/media/publications/fast-rayaxis-aligned-bounding-box-overlap-tests-using-ray-slopes.pdf\n     * @param {AABB} aabb - axis-aligned bounding-box instance\n     * @return {bool} did intersection occur\n     */\n    //intersectAABB: function(aabb) {\n        //// Low hanging fruit, if ray origin is inside aabb, then automatic\n        //// intersection\n        //if (aabb.contains(this.origin)) {\n            //return true;\n        //}\n\n        //// Steps:\n        //// 1. Get slope of line from ray origin to aabb.min and aabb.max\n        //// 2. if slope of ray is between slopes generated in step 1, then\n        //// ray intersects\n        ////\n        //// Handle two cases : positive vs. negative slope\n        //// If slope is positive, use min + width and min + height as corners to\n        //// check\n        //// Otherwise use regular min and max\n        //let min, max;\n        //if (this.slope > 0) {\n            //min = {x: aabb.max.x, y: aabb.min.y};\n            //max = {x: aabb.min.x, y: aabb.max.y};\n        //} else {\n            //min = aabb.min;\n            //max = aabb.max;\n        //}\n\n        //let s1 = (min.y - this.origin.y) / (min.x - this.origin.x);\n        //let s2 = (max.y - this.origin.y) / (max.x - this.origin.x);\n        //let smin = Math.min(s1, s2);\n        //let smax = Math.max(s1, s2);\n\n        //if (this.slope < smax && this.slope > smin) {\n            //return true;\n        //}\n        //return false;\n    //},\n\n    /**\n     * Internally used to update point of intersection property\n     * @param {Point} intPoint - object with x and y properties representing\n     * intersection point\n     * @param {Vector} segVec - vector object that was intersected\n     * @param {Body} body - body that was intersected\n     */\n    updateIntersectionPoint: function(intPoint, segVec, body) {\n        let px = this.origin.x;\n        let py = this.origin.y;\n        let ix = intPoint.x;\n        let iy = intPoint.y;\n\n        // If there was a previously stored intersection point,\n        // check if this one is closer,\n        // and if so update it's values\n        if (this.intersectionPoint) {\n            if (distance(px, py, ix, iy) <\n                distance(px, py, this.intersectionPoint.x, this.intersectionPoint.y)) {\n                this.intersectionPoint = {x: ix, y: iy};\n                this.intersectingBody = body;\n                this.intersectingSegment = segVec;\n            }\n        } else {\n            // We don't yet have an intersection point, so make a new\n            // one\n            this.intersectionPoint = {x: ix, y: iy};\n            this.intersectingBody = body;\n            this.intersectingSegment = segVec;\n        }\n    }\n};\n\n/**\n * 'Constructor' function\n * @param {number} x - origin x\n * @param {number} y - origin y\n * @param {number} dir - direction in radians (or degrees if 'degrees' param\n * = true)\n * @param {bool} degrees - optional flag, if true, then read direction as\n * degrees\n *\n * @return {object} ray object\n */\nvar ray = function(x, y, dir, degrees) {\n    let R = Object.create(Ray);\n    R.init(x, y, dir, degrees);\n    return R;\n};\n\nexport default ray;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/geometries/Ray.js\n **/","import hash from '../geometries/SpatialHash';\n\nconst System = {};\nSystem.prototype = {\n    init: function(params) {\n        this.frames = [];\n        this.objects = [];\n        this.waves = [];\n        this.childWaves = [];\n        this.rays = [];\n        this.width = params.width || 600;\n        this.height = params.height || 300;\n\n        let divisor = params.cellSize ? params.cellSize : 100;\n\n        let cellSize = this.width / Math.floor(this.width / divisor);\n        this.hash = hash(cellSize, this.width, this.height);\n        this.currentRayId = 0;\n    },\n    addFrame: function(frame) {\n        this.frames.push(frame);\n    },\n    addRay: function(ray) {\n        this.rays.push(ray);\n    },\n    addWave: function(wave) {\n        this.waves.push(wave);\n    },\n    addChildWave: function(wave) {\n        this.childWaves.push(wave);\n    },\n\n    /**\n     * Add objects to the system\n     * Objects not added will not be rendered\n     * or updated\n     *\n     * @param {Body|Body[]} b - a body object, or array of body objects\n     */\n    addObject: function(b) {\n        if (typeof b === 'object' && b.length !== undefined) {\n            // b is an array\n            b.forEach(body => {\n                this.objects.push(body);\n            });\n        } else {\n            this.objects.push(b);\n        }\n    },\n    update: function() {\n        this.hash.clear();\n        this.objects.forEach(body => {\n            this.hash.insertBody(body);\n            body.update();\n        });\n\n        // Reset currentRayID during each update loop so we can reuse these\n        // ID's\n        this.currentRayId = 0;\n        this.childWaves = [];\n        this.waves.forEach(wave => {\n            wave.update(this);\n            this.traverseWaves(wave);\n        });\n    },\n    traverseWaves: function(wave) {\n        if (wave.children.length !== 0) {\n            wave.children.forEach(child => {\n                this.addChildWave(child);\n                this.traverseWaves(child);\n            });\n        }\n    }\n};\n\nconst system = function(params) {\n    const s = Object.create(System.prototype);\n    s.init(params);\n    return s;\n};\n\nexport default system;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/system/System.js\n **/","const SpatialHash = {};\nSpatialHash.prototype = {\n    init: function(cellSize, width, height) {\n        this.cellSize = cellSize;\n        this.width = width;\n        this.height = height;\n        this.numRows = Math.ceil(height / cellSize);\n        this.numCols = width / cellSize;\n    },\n\n    /**\n     * Return location that should store this point\n     * @param {object} point - object with x and y properties\n     * @return {object} - bucket which th epoint falls into\n     */\n    hash: function(point) {\n        return {col: Math.floor(point.x / this.cellSize), row: Math.floor(point.y / this.cellSize)};\n    },\n    insertBody: function(body) {\n        // Hash the vertices of the AABB\n        let min = this.hash(body.aabb.min);\n        let max = this.hash(body.aabb.max);\n\n        // Iterate over rectangular region\n        // And put the object in all buckets that\n        // it hits\n        for (let r = min.row; r < max.row + 1; r++) {\n            for (let c = min.col; c < max.col + 1; c++) {\n                if (this.contents[r]) {\n                    if (this.contents[r][c]) {\n                        this.contents[r][c].push(body);\n                    } else {\n                        this.contents[r][c] = [body];\n                    }\n                } else {\n                    this.contents[r] = {};\n                    this.contents[r][c] = [body];\n                }\n            }\n        }\n    },\n    removeBody: function(body) {\n        let min = this.hash(body.aabb.min);\n        let max = this.hash(body.aabb.max);\n\n        // Iterate over rectangular region\n        // And remove the object from all found buckets\n        for (let r = min.row; r < max.row + 1; r++) {\n            for (let c = min.col; c < max.col + 1; c++) {\n                let idx = this.contents[r][c].indexOf(body);\n                if (idx !== -1) {\n                    this.contents[r][c].splice(idx, 1);\n                }\n            }\n        }\n    },\n    queryBody: function(body) {\n        let min = this.hash(body.aabb.min);\n        let max = this.hash(body.aabb.max);\n        let nearby = [];\n\n        // Iterate over rectangular region\n        // And put the object in all buckets that\n        // it hits\n        for (let r = min.row; r < max.row + 1; r++) {\n            for (let c = min.col; c < max.col + 1; c++) {\n                this.contents[r][c].forEach(b => {\n                    if (nearby.indexOf(b) === -1 && b !== body) {\n                        nearby.push(b);\n                    }\n                });\n            }\n        }\n        return nearby;\n    },\n    queryPoint: function(point) {\n        let hash = this.hash(point);\n        return hash;\n    },\n    clear: function() {\n        this.contents = {};\n    }\n};\n\nconst hash = function(cellSize, width, height) {\n    let h = Object.create(SpatialHash.prototype);\n    h.init(cellSize, width, height);\n    return h;\n};\n\nexport default hash;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/geometries/SpatialHash.js\n **/","import * as math from '../math/math';\nconst Renderer = {};\nRenderer.prototype = {\n    init: function(params) {\n        this.clearBackground = true;\n        this.debug = params.debug || false;\n        this.background = params.background || 'black';\n\n        // Pardon the ugly ternary...\n        this.canvas = (typeof params.canvas === 'undefined') ?\n            (function() {\n                let c = document.createElement('canvas');\n                c.id = 'canvas';\n                // Set default size\n                document.body.appendChild(c);\n                return c;\n            })() : (function() {\n                // Default values for canvas size\n                let c = document.getElementById(params.canvas);\n                return c;\n            })();\n\n        if (this.debug) {\n            window.sciDebug = true; window.ctx = this.canvas.getContext('2d');\n        }\n\n        //this.canvas.width = params.width || 600;\n        //this.canvas.height = params.height || 300;\n        this.ctx = this.canvas.getContext('2d');\n    },\n    /**\n     * Draw bodies and waves\n     * @private\n     * @param {object} system - phys.system object containing all objects\n     */\n    //renderObjects: function(system) {\n        //system.objects.forEach(body => {\n            //this.draw(body);\n            ////body.draw(this.ctx);\n        //});\n\n        //system.waves.forEach(wave => {\n            //wave.trace(system, this.ctx);\n            ////wave.draw(this.ctx);\n        //});\n\n        ////system.rays.forEach(ray => {\n        ////ray.draw(ctx);\n        ////});\n    //},\n    drawBody: function(body) {\n        if (this.debug) {\n            this.ctx.beginPath();\n            this.ctx.strokeStyle = 'red';\n            this.ctx.lineWidth = 1;\n\n            let aabb = body.aabb;\n            let x = aabb.min.x;\n            let y = aabb.min.y;\n            let w = aabb.max.x - x;\n            let h = aabb.max.y - y;\n            this.ctx.rect(x, y, w, h);\n            this.ctx.stroke();\n        }\n        switch (body.type) {\n            case 'rectangle': {\n                this.ctx.fillStyle = body.style.fillStyle;\n                this.ctx.lineWidth = body.style.lineWidth;\n                this.ctx.strokeStyle = body.style.strokeStyle;\n                let x, y, w, h;\n                switch (body._mode) {\n                    case 'LEFT': {\n                        x = body.position.x;\n                        y = body.position.y;\n                        w = body.width;\n                        h = body.height;\n                        break;\n                    }\n                    case 'CENTER':\n                        w = body.width;\n                        h = body.height;\n                        x = body.position.x - w / 2;\n                        y = body.position.y - h / 2;\n                        break;\n                    case 'RIGHT':\n                        w = body.width;\n                        h = body.height;\n                        x = body.position.x - w;\n                        y = body.position.y;\n                        break;\n                    default:\n                        break;\n                }\n                this.ctx.lineJoin = 'miter';\n                this.ctx.beginPath();\n                this.ctx.moveTo(x, y);\n                this.ctx.lineTo(x + w, y);\n                this.ctx.lineTo(x + w, y + h);\n                this.ctx.lineTo(x, y + h);\n                this.ctx.closePath();\n                this.ctx.stroke();\n                break;\n            }\n            case 'circle': {\n                this.ctx.fillStyle = body.style.fillStyle;\n                this.ctx.lineWidth = body.style.lineWidth;\n                this.ctx.strokeStyle = body.style.strokeStyle;\n\n                this.ctx.beginPath();\n                this.ctx.ellipse(body.position.x, body.position.y, body.radius, body.radius, 0, 0, Math.PI * 2);\n                this.ctx.closePath();\n                this.ctx.stroke();\n                this.ctx.fill();\n            }\n                break;\n            case 'polygon': {\n                this.ctx.fillStyle = body.style.fillStyle;\n                this.ctx.lineWidth = body.style.lineWidth;\n                this.ctx.strokeStyle = body.style.strokeStyle;\n                this.ctx.beginPath();\n                this.ctx.lineJoin = 'miter';\n                this.ctx.moveTo(body.vertices[0].x, body.vertices[0].y);\n                for (let i = 1; i < body.vertices.length; i++) {\n                    let v = body.vertices[i];\n                    this.ctx.lineTo(v.x, v.y);\n                }\n                this.ctx.closePath();\n                this.ctx.fill();\n                this.ctx.stroke();\n                break;\n            }\n            default:\n                break;\n        }\n    },\n    drawWave: function(wave) {\n        // No matter what the angle mode, always use radians\n        let angle = wave.mode === 'DEGREES' ? math.degToRad(wave.direction) : wave.direction;\n        this.ctx.fillStyle = wave.style.fillStyle;\n        this.ctx.lineWidth = wave.style.lineWidth;\n        this.ctx.strokeStyle = wave.style.strokeStyle;\n        this.ctx.beginPath();\n\n        // If debug == true, draw waves in certain colors\n        if (this.debug) {\n            if (wave.type === 'incident') {\n                // Draw starting circle\n                this.ctx.fillStyle = 'yellow';\n                this.ctx.beginPath();\n                this.ctx.ellipse(wave.position.x, wave.y, 3, 3, 0, 0, Math.PI * 2);\n                this.ctx.fill();\n                this.ctx.stroke();\n                this.ctx.strokeStyle = 'green';\n            } else if (wave.type === 'refracted') {\n                this.ctx.strokeStyle = 'blue';\n            } else if (wave.type === 'reflected') {\n                this.ctx.strokeStyle = 'orange';\n            }\n        }\n\n        this.ctx.globalAlpha = math.map(wave.intensity, 0, 1, 0.3, 1);\n        this.ctx.moveTo(wave.position.x, wave.position.y);\n\n        // If the wave intersects an object ahead, then\n        // only draw to that object. Otherwise draw an arbitrary length\n        if (wave.ray.intersectionPoint) {\n            this.ctx.lineTo(wave.ray.intersectionPoint.x, wave.ray.intersectionPoint.y);\n            this.ctx.stroke();\n\n            // Draw intersection points as circles\n            // when in debug mode\n            if (this.debug === true) {\n                this.ctx.beginPath();\n                this.ctx.strokeStyle = 'red';\n                this.ctx.ellipse(wave.ray.intersectionPoint.x, wave.ray.intersectionPoint.y, 3, 3, 0, 0, Math.PI * 2);\n                this.ctx.stroke();\n            }\n        } else {\n            this.ctx.lineTo(2000 * Math.cos(angle) + wave.position.x, 2000 * Math.sin(angle) + wave.position.y);\n            this.ctx.stroke();\n        }\n        this.ctx.globalAlpha = 1;\n    },\n\n    render: function(system) {\n        // The first time the system renders,\n        // capture a local reference to it\n        // to be used to restart the renderer later\n        // if it's ever stopped\n        if (!this.system) {\n            this.system = system;\n            this.canvas.width = this.system.width;\n            this.canvas.height = this.system.height;\n        }\n\n        // In order to pass 'system' into render\n        // we have to wrap it in a function before\n        // passing it to requestAnimationFrame\n        let self = this;\n        this._requestID = requestAnimationFrame(function() {\n            self.render(system);\n        });\n\n        // Clear background\n        if (this.clearBackground) {\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        }\n        // Draw background\n        this.ctx.beginPath();\n        this.ctx.fillStyle = this.background;\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Update the system\n        system.update();\n\n        // Draw all objects + waves\n        system.objects.forEach(obj => {\n            this.drawBody(obj);\n        });\n\n        system.waves.forEach(wave => {\n            this.drawWave(wave);\n        });\n\n        system.childWaves.forEach(wave => {\n            this.drawWave(wave);\n        });\n\n        // If in debug mode, draw spatial hash\n        // and highlight nodes that contain items in red\n        if (this.debug === true) {\n            let cellSize = system.hash.cellSize;\n            for (let i = 0; i < system.hash.width; i += cellSize) {\n                for (let j = 0; j < system.hash.height; j += cellSize) {\n                    this.ctx.beginPath();\n                    this.ctx.strokeStyle = 'green';\n                    this.ctx.rect(i, j, cellSize, cellSize);\n                    this.ctx.stroke();\n                }\n            }\n            Object.keys(system.hash.contents).forEach(row => {\n                Object.keys(system.hash.contents[row]).forEach(col => {\n                    // Draw all squares\n                    this.ctx.beginPath();\n                    this.ctx.strokeStyle = 'green';\n                    if (system.hash.contents[row][col].length !== 0) {\n                        this.ctx.strokeStyle = 'red';\n                    }\n                    this.ctx.rect(col * cellSize, row * cellSize, cellSize, cellSize);\n                    this.ctx.stroke();\n                });\n            });\n        }\n    },\n\n    /**\n     * Set's size of renderers canvas\n     * @param {number} width - width of canvas\n     * @param {number} height - height of canvas\n     */\n    setSize: function(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        //if (shouldUpdateStyle) {\n        //canvas.style.width = `${width}px`;\n        //canvas.style.height = `${height}px`;\n        //}\n    },\n    /**\n     * Stop animation cycle\n     */\n    stop: function() {\n        cancelAnimationFrame(this.requestID);\n    },\n\n    /**\n     * Restart animation cycle\n     */\n    start: function() {\n        this.render(this.system);\n    }\n};\n\nvar renderer = function(params) {\n    let R = Object.create(Renderer.prototype);\n    R.init(params);\n    return R;\n};\n\nexport default renderer;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/renderer/Renderer.js\n **/","/* eslint\n    \"no-multi-spaces\": \"off\"\n */\nimport Body from './Body';\nimport aabb from '../geometries/AABB';\n\nvar rect = function(options) {\n    options = options || {};\n\n    let B = Object.create(Body);\n    B.init(options);\n    B.type = 'rectangle';\n    B._mode = options.mode || 'LEFT';\n\n    // Define getters and setters for mode\n    Object.defineProperty(B, 'mode', {\n        get: function() {\n            return this._mode;\n        },\n        set: function(m) {\n            if (this._mode !== m && this.type === 'rectangle') {\n                switch (m) {\n                    case 'LEFT':\n                    case 'CENTER':\n                    case 'RIGHT':\n                        this._mode = m;\n                        this.updateVertices();\n                        break;\n                    default:\n                        console.warn(`Cannot set mode to ${m}`);\n                        break;\n                }\n            } else {\n                console.warn(`'mode' is only available on rectangles`);\n            }\n        }\n    });\n\n    /**\n     * Update location of vertices - used in update loop\n     */\n    B.updateVertices = function() {\n        let w = this.width,\n            h = this.height,\n            x, y;\n        switch (this._mode) {\n            case 'LEFT':\n                x = this.position.x;\n                y = this.position.y;\n                break;\n            case 'CENTER':\n                x = this.position.x - w / 2;\n                y = this.position.y - h / 2;\n                break;\n            case 'RIGHT':\n                x = this.x - w;\n                y = this.y;\n                break;\n            default:\n                break;\n        }\n        this.vertices = [\n            {x: x,     y: y},\n            {x: x + w, y: y},\n            {x: x + w, y: y + h},\n            {x: x,     y: y + h}\n        ];\n    };\n\n    /**\n     * Update segments - used in update loop\n     */\n    B.updateSegments = function() {\n        // What mode are we in?\n        let x, y, w, h;\n        //let pos = this.position;\n        switch (this._mode) {\n            case 'LEFT':\n                x = this.position.x;\n                y = this.position.y;\n                w = this.width;\n                h = this.height;\n                break;\n            case 'CENTER':\n                w = this.width;\n                h = this.height;\n                x = this.position.x - w / 2;\n                y = this.position.y - h / 2;\n                break;\n            case 'RIGHT':\n                w = this.width;\n                h = this.height;\n                x = this.x - w;\n                y = this.y;\n                break;\n            default:\n                break;\n        }\n\n        this.segments = [\n            [[x, y], [x + w, y]],\n            [[x + w, y], [x + w, y + h]],\n            [[x + w, y + h], [x, y + h]],\n            [[x, y + h], [x, y]]\n        ];\n    };\n\n    B.isPointInterior = function(x, y) {\n        let bx = B.position.x,\n            by = B.position.y;\n\n        if (x >= bx &&\n            x <= bx + B.width &&\n            y >= by &&\n            y <= by + B.height) {\n            return true;\n        }\n        return false;\n    };\n\n    B.updateVertices();\n    B.aabb = aabb(B);\n    return B;\n};\n\nexport default rect;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bodies/Rect.js\n **/","/* eslint \"no-unused-vars\": \"off\" */\n// What should a body be able to do?\n// 1. Attach to other bodies or surfaces\n// 2. Respond to forces (spring, friction)\n// 3. Move according to velocity and acceleration\n\nimport materials from '../extras/materials.json';\nimport vector from '../math/Vector';\nimport * as math from '../math/math';\n\n/**\n * Convenience Function so user doesn't have use 'new' keyword\n * @param {object} options - initialization options\n * @return {Body} instance of Body\n */\n\nlet Body = {\n    init: function(options) {\n        options = options || {};\n\n        // Warn user if a body object is initialized with nothing or an empty\n        // object\n        if (Object.keys(options).length === 0 && options.constructor === Object) {\n            console.warn('You probably should initialize body objects with some values...just sayin');\n        }\n\n        this.style = {\n            fillStyle: options.fillStyle || 'rgba(0,0,0,0)',\n            lineWidth: options.lineWidth || 2,\n            strokeStyle: options.strokeStyle || '#abcabc'\n        };\n        this.mass = options.mass || 0;\n        this.position = vector(options.x || 0, options.y || 0);\n        this.velocity = vector(\n            (options.velocity && options.velocity.x) || 0,\n            (options.velocity && options.velocity.y) || 0\n        );\n        this.height = options.height || 10;\n        this.width = options.width || 10;\n        this.refractiveIndex = options.refractiveIndex || 1;\n        this.material = options.material || 'GLASS';\n        this.materialColor = options.fillStyle || 'black';\n        this.mirror = options.mirror || false;\n        this.intersectionPoints = {};\n\n         // If the material is provided, set refractive index based on materials\n         // database\n        // TODO: Make setting either refractive index or material possible!!!\n        if (options.material && options.refractiveIndex) {\n            this.refractiveIndex = options.refractiveIndex;\n            this.material = options.material;\n            console.warn('Setting both the material and the refractive index at the same time may cause some unexpected behavior'); //eslint-disable-line\n        } else if (options.material) {\n            // Check to make sure the material exists in the database\n            if (materials[this.material]) {\n                this.refractiveIndex = materials[this.material].refractiveIndex;\n            } else if (this.material === undefined || this.material === null) {\n                this.material = 'default';\n                this.refractiveIndex = 1;\n            } else {\n                console.error('the material ' + this.material + ' is not recognized. See the docs for supported default materials'); //eslint-disable-line\n            }\n        } else if (options.refractiveIndex) {\n            this.refractiveIndex = options.refractiveIndex;\n        } else {\n            this.refractiveIndex = 1.33;\n        }\n    },\n\n    freeze: function() {\n        this._cachedVelocity = this.velocity.clone();\n        this.velocity.x = 0;\n        this.velocity.y = 0;\n    },\n\n    unfreeze: function() {\n        if (this._cachedVelocity) {\n            this.velocity.x = this._cachedVelocity.x;\n            this.velocity.y = this._cachedVelocity.y;\n        } else {\n            console.warn('cannot unfreeze a non-frozen object');\n        }\n    },\n\n    update: function() {\n        this.position.add(this.velocity);\n\n        if (this.updateSegments) {\n            this.updateSegments();\n        }\n\n        if (this.updateVertices) {\n            this.updateVertices();\n        }\n\n        // For each update loop, reset intersection points to zero\n        this.intersectionPoints = {};\n\n        this.aabb.update();\n    }\n\n};\n\nexport default Body;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bodies/Body.js\n **/","module.exports = {\n\t\"GLASS\": {\n\t\t\"refractiveIndex\": 1.5\n\t},\n\t\"AIR\": {\n\t\t\"refractiveIndex\": 1.000277\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/extras/materials.json\n ** module id = 11\n ** module chunks = 0\n **/","/* eslint\n    \"no-else-return\": \"off\"\n */\nlet AABB = {\n    init: function(body) {\n        this.body = body;\n        let bounds = this.findMinMax(body);\n        this.max = bounds.max;\n        this.min = bounds.min;\n    },\n    /**\n     * Finds bounds of AABB\n     * Does not set any properties\n     * If you want to find and set, call AABB.update()\n     * @return {object} bounds\n     */\n    findMinMax: function() {\n        // Only deal with two types of bodies...Those with vertices, and\n        // circles\n        if (this.body.vertices) {\n            let minx,\n                miny,\n                maxx,\n                maxy;\n            this.body.vertices.forEach(v => {\n                let x = v.x,\n                    y = v.y;\n\n                // If nothing has been set, then set it\n                if (typeof minx === 'undefined') {\n                    minx = x;\n                } else if (typeof minx !== 'undefined' && x < minx) {\n                    // Something's already there, only update if x < minx\n                    minx = x;\n                }\n\n                if (typeof miny === 'undefined') {\n                    miny = y;\n                } else if (typeof miny !== 'undefined' && y < miny) {\n                    miny = y;\n                }\n\n                if (typeof maxx === 'undefined') {\n                    maxx = x;\n                } else if (typeof maxx !== 'undefined' && x > maxx) {\n                    maxx = x;\n                }\n\n                if (typeof maxy === 'undefined') {\n                    maxy = y;\n                } else if (typeof maxy !== 'undefined' && y > maxy) {\n                    maxy = y;\n                }\n            });\n\n            return {\n                max: {\n                    x: maxx,\n                    y: maxy\n                },\n                min: {\n                    x: minx,\n                    y: miny\n                }\n            };\n        } else {\n            // Assume it's a circle\n            let cx = this.body.position.x,\n                cy = this.body.position.y,\n                r = this.body.radius;\n            return {\n                max: {\n                    x: cx + r,\n                    y: cy + r\n                },\n                min: {\n                    x: cx - r,\n                    y: cy - r\n                }\n            };\n        }\n    },\n\n    /**\n     * Returns true of point is inside AABB\n     * @param {Point} point - must contain x and y props\n     * @return {bool} true if point is inside AABB\n     */\n    contains: function(point) {\n        let x = point.x,\n            y = point.y;\n        if (x >= this.min.x &&\n            x <= this.max.x &&\n            y >= this.min.y &&\n            y <= this.max.y) {\n            return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Updates the AABB\n     */\n    update: function() {\n        let bounds = this.findMinMax();\n        this.max = bounds.max;\n        this.min = bounds.min;\n    }\n};\n\nlet aabb = function(body) {\n    let ab = Object.create(AABB);\n    ab.init(body);\n    return ab;\n};\n\nexport default aabb;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/geometries/AABB.js\n **/","/* eslint \"no-unused-vars\": \"off\" */\nimport {degToRad, radToDeg, crossProduct2D, dotProduct2D, distance, map} from '../math/math';\nimport vector, {Vector} from '../math/Vector';\nimport ray from '../geometries/Ray';\n\nlet Wave = {\n    init: function(options) {\n        options = options || {};\n        const speedOfLight = 299792458;\n        this.children = [];\n        //this.outerBodies = [];\n        this.style = {\n            lineWidth: options.lineWidth || 1,\n            strokeStyle: options.strokeStyle || '#456abc'\n        };\n\n        this.x = options.x || 10;\n        this.y = options.y || 10;\n        this.position = vector(options.x, options.y);\n        this.waveSpeed = options.waveSpeed || speedOfLight;\n        this.frequency = options.frequency || 1000;\n        this.wavelength = this.waveSpeed / this.frequency;  // Computed Property\n        this.velocity = options.velocity || vector(0, 0);\n        this.direction = options.direction || 0;\n        this.mode = options.mode || 'RADIAN';\n        this.intensity = options.intensity || 1;\n        this.type = options.type || 'incident';\n        this.parent = options.parent || null;\n        this.n1 = options.n1 || 1;\n        this.n2 = options.n2 || 1;\n        this.lastIntersection = {};\n\n        // create ray for detecting body intersections\n        this.ray = ray(this.position.x, this.y, this.direction, this.mode === 'DEGREES' || null);\n    },\n\n    update: function(system) {\n        this.ray.trace(system);\n\n        // Remove children on every update\n        this.children = [];\n        // If the ray intersected a point...\n        if (this.ray.intersectionPoint) {\n            this.lastIntersection = this.ray.intersectionPoint;\n            this.children = this.createChildren();\n\n            this.children.forEach(child => {\n                child.update(system);\n            });\n        }\n    },\n    createChildren: function() {\n        //Vector implementation of reflected and refracted waves here:\n        //http://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n        //Normalize ray vector = this.ray.direction\n\n        // Find the normal vector (method of which depends on type of body)\n        // There are two possible normal vectors, but\n        // which one do we want?\n        // one which dot product with ray vector < 0 is what we want\n        // http://gamedev.stackexchange.com/questions/85850/collision-intersection-of-2d-ray-to-line-segment\n        let normal;\n\n        //selectNormal();\n        // TODO: Wrap this in it's own function (i.e. findNormal function)\n        let bType = this.ray.intersectingBody.type;\n        if (bType === 'rectangle' || bType === 'polygon') {\n            let intSeg = this.ray.intersectingSegment;\n\n            intSeg.normalize();\n            let dot = intSeg.dot(this.ray.direction);\n            let normals = [vector(-intSeg.y, intSeg.x), vector(intSeg.y, -intSeg.x)];\n\n            let that = this;\n            normals.forEach(n => {\n                if (n.dot(that.ray.direction) < 0) {\n                    normal = n;\n                }\n            });\n        } else if (bType === 'circle') {\n            let cx = this.ray.intersectingBody.position.x;\n            let cy = this.ray.intersectingBody.position.y;\n            let ix = this.ray.intersectionPoint.x;\n            let iy = this.ray.intersectionPoint.y;\n            let v1 = vector(ix - cx, iy - cy),\n                v2 = vector(cx - ix, cy - iy);\n            v1.normalize();\n            v2.normalize();\n            let normals = [\n                v1,\n                v2\n            ];\n            let that = this;\n            normals.forEach(function(n) {\n                //n.normalize();\n                if (n.dot(that.ray.direction) < 0) {\n                    normal = n;\n                }\n            });\n            if (normal === undefined) {\n                // We intersect at a tangent on a circle???\n                // TODO: Fix this!!!\n                normal = normals[0];\n            }\n        }\n\n        // child waves - reflected and refracted\n        // Calculate reflected vector\n        // https://en.wikipedia.org/wiki/Snell%27s_law#Vector_form\n        // http://stackoverflow.com/questions/5454661/reflection-how-do-i-do-it\n        // Reflected vector looks like this:\n        // r = a - 2(a dot n) * n\n        let tmpTerm = 2 * this.ray.direction.dot(normal);\n        let tmpVec = normal.clone();\n        tmpVec.multiply(2 * this.ray.direction.dot(normal));\n        let rVec = this.ray.direction.clone();\n        rVec.subtract(tmpVec);\n\n        // Refracted vector\n        // Are we inside a body?\n        // get origin points of wave, check if they are interior to the\n        // intersecting body, if so, n1 = body.refractiveIndex, if not, n1\n        // takes on refractive index of outer context,\n        // which we can find from it's parent wave\n        // If we have a body to intersect with...\n        if (this.type === 'incident' && this.ray.outerBodies.length > 0) {\n            //Grab the last one (the body on top)\n            this.n1 = this.ray.outerBodies[this.ray.outerBodies.length - 1].refractiveIndex;\n        }\n\n        // TODO: Figure out how to handle picking proper refractive index\n        // values\n        // for child rays\n        if (this.ray.intersectingBody) {\n            switch (this.type) {\n                case 'refracted':\n                    if (this.parent && this.parent.ray.intersectingBody &&\n                        this.parent.ray.intersectingBody === this.ray.intersectingBody) {\n                        this.n1 = this.parent.n2;\n                        this.n2 = this.parent.n1;\n                    } else {\n                        this.n1 = this.parent.n2;\n                        this.n2 = this.ray.intersectingBody.refractiveIndex;\n                    }\n                    break;\n                case 'reflected':\n                    if (this.parent && this.parent.ray.intersectingBody &&\n                        this.parent.ray.intersectingBody === this.intersectingBody) {\n                        this.n1 = this.parent.n1;\n                        this.n2 = this.parent.n2;\n                    } else {\n                        this.n1 = this.parent.n1;\n                        this.n2 = this.ray.intersectingBody.refractiveIndex;\n                    }\n                    break;\n                case 'incident':\n                    this.n2 = this.ray.intersectingBody.refractiveIndex;\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            // There's no intersection point ahead of this ray, so it's\n            // refractive indices are irrelevant\n            this.n1 = 1;\n            this.n2 = 1;\n            // If the ray won't intersect another body,\n            // then it must be outside of a body\n            //n2 = 1;\n\n            // n1 must take on the index of where the parent ray currently\n            // exists\n            //n1 = props.parent.intersectingBody.refractiveIndex;\n        }\n\n        let theta1 = Math.PI - this.ray.direction.angleTo(normal);\n        let theta2 = Math.asin(this.n1 * Math.sin(theta1) / this.n2);\n\n        // Vector formulation for refracted wave\n        // t = n1/n2 * rayVector + (n1/n2 * cos(theta1) - sqrt(1\n        // - sin2(theta2))) * normal\n        let sin2theta2 = (this.n1 / this.n2) * (this.n1 / this.n2) * (1 - (Math.cos(theta1) * Math.cos(theta1)));\n        let tVec = Vector.multiply((this.n1 / this.n2), this.ray.direction);\n        let normCopy = Vector.multiply(normal, (this.n1 / this.n2) * Math.cos(theta1) - Math.sqrt(1 - sin2theta2));\n        tVec.add(normCopy);\n\n        // Reflection Coefficient\n        // R = R0 + (1 - R0) * (1 - cos(theta1))^5 where R0 = (n1 - n2 / n1\n        // + n2)^2\n        let _r0 = (this.n1 - this.n2) / (this.n1 + this.n2);\n        let R0 = _r0 * _r0;\n        let _r0tmp;\n\n        // Angles must be positive, so if we get a negative value for an\n        // angle, just flip it\n        if (this.n1 <= this.n2) {\n            _r0tmp = (1 - (Math.cos(theta1) < 0 ? -Math.cos(theta1) : Math.cos(theta1)));\n        } else if (this.n1 > this.n2) {\n            _r0tmp = (1 - (Math.cos(theta2) < 0 ? -Math.cos(theta2) : Math.cos(theta2)));\n        }\n\n        // TODO: Refactor this to eliminate some checks if body is a mirror\n        let R = R0 + (1 - R0) * Math.pow(_r0tmp, 5);\n        let T = 1 - R;  // Refracion Coefficient\n        // Total Internal Reflection\n        if (Math.sin(theta1) > this.n2 / this.n1) {\n            R = 0.95;\n            T = 0;\n        }\n\n        // If the material should be treated as a mirror\n        if (this.ray.intersectingBody.mirror === true) {\n            R = 0.9;\n            T = 0;\n        }\n\n        let RI = this.intensity * R;\n        let TI = this.intensity * T;\n\n        // Add 2 child waves - reflected and refracted\n        // Trace reflected wave\n        // Have to offset the waves by at least a pixel,\n        // otherwise we'll end up in a never ending\n        // call stack when each child wave always produces\n        // 2 new child waves, forever...\n        let rVecAngle = rVec.getAngle();\n        let tVecAngle = tVec.getAngle();\n        let children = [];\n        if (RI > 0.01) {\n            let reflectedWave = wave({ // eslint-disable-line\n                x: this.ray.intersectionPoint.x + Math.cos(rVecAngle),\n                y: this.ray.intersectionPoint.y + Math.sin(rVecAngle),\n                direction: rVecAngle,\n                intensity: RI,\n                type: 'reflected',\n                parent: this,\n                n1: this.n1,\n                n2: this.n2,\n                lineWidth: this.style.lineWidth,\n                strokeStyle: this.style.strokeStyle\n            });\n            children.push(reflectedWave);\n        }\n\n        if (TI > 0.01) {\n            let refractedWave = wave({  // eslint-disable-line\n                x: this.ray.intersectionPoint.x - normal.x,\n                y: this.ray.intersectionPoint.y - normal.y,\n                direction: tVecAngle,\n                intensity: TI,\n                type: 'refracted',\n                parent: this,\n                n1: this.n1,\n                n2: this.n2,\n                lineWidth: this.style.lineWidth,\n                strokeStyle: this.style.strokeStyle\n            });\n            children.push(refractedWave);\n        }\n        return children;\n    }\n};\n\nconst wave = function(options) {\n    let W = Object.create(Wave);\n    W.init(options);\n    return W;\n};\n\nexport default wave;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bodies/Wave.js\n **/","import Body from './Body';\nimport aabb from '../geometries/AABB';\nimport {distance} from '../math/math';\n\nlet circle = function(options) {\n    options = options || {};\n    let B = Object.create(Body);\n    B.init(options);\n\n    B.radius = options.radius || 0;\n    B.type = 'circle';\n    B.aabb = aabb(B);\n\n    B.isPointInterior = function(x, y) {\n        let bx = B.position.x,\n            by = B.position.y;\n        if (distance(x, y, bx, by) <= B.radius) {\n            return true;\n        }\n        return false;\n    };\n\n    return B;\n};\n\nexport default circle;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bodies/Circle.js\n **/","import Body from './Body';\nimport aabb from '../geometries/AABB';\nimport vector from '../math/Vector';\n\nvar polygon = function(options) {\n    options = options || {};\n\n    var B = Object.create(Body);\n    if (!options.vertices) {\n        throw new Error('Polygons MUST be initialized with vertices. See docs.');\n    }\n    B.init(options);\n\n    //Initialize vetices as vectors\n    // private vertices, relative to x and y\n    B._relativeVertices = [];\n\n    // public vertices, (contain world coords);\n    B.vertices = [];\n    options.vertices.forEach(vert => {\n        B._relativeVertices.push(vector(vert.x, vert.y));\n        B.vertices.push(vector(options.x + vert.x, options.y + vert.y));\n    });\n\n    // Set type\n    B.type = 'polygon';\n\n    // Update all vertices based on position\n    B.updateVertices = function() {\n        B.vertices.forEach((vert, index) => {\n            let relVert = B._relativeVertices[index];\n            vert.x = relVert.x + B.position.x;\n            vert.y = relVert.y + B.position.y;\n        });\n    };\n\n    B.isPointInterior = function(x, y) {\n        var inside = false;\n        for (var i = 0, j = B.vertices.length - 1; i < B.vertices.length; j = i++) {\n            let vi = B.vertices[i];\n            let vj = B.vertices[j];\n            var xi = vi.x,\n                yi = vi.y;\n            var xj = vj.x,\n                yj = vj.y;\n\n            var intersect = ((yi > y) !== (yj > y)) &&\n                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n            if (intersect) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    };\n\n    // Initialize...\n    B.updateVertices();\n    B.aabb = aabb(B);\n    return B;\n};\n\nexport default polygon;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bodies/Polygon.js\n **/"],"sourceRoot":""}